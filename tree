/usr/src/sys/uvm
|-- uvm.h 
	* Contains global uvm state data
		- Queue and locks(mutex) for active/inactive and free pages
		- State for pagedaemon and async io tasks
		- Bool indicating when init has completed
		- Entity type bits for indicating properties of map entries
		- Some uvm_addr decls(unsure if these should be here)
|-- uvm_addr.c
|-- uvm_addr.h
	* Contains prototypes of uvm addr selector funcs and ds
		- Addr selectors are different algorithms that decide where
		  to put addresses. They are defined by a struct containing 
		  an interface(struct of function pointers) and some state
		  data(max and min addrs). The interface has a few methods
		  for selecting, freeing, and printing addresses. There are
		  5 different selectors atm:
			1. uaddr_lin: unsure, disabled by default
			2. uaddr_rnd: random algo addrs
			3. uaddr_bestfit: bestfit algo addrs
			4. uaddr_pivot: pivot algo addrs(patch this)
			5. uaddr_stack_brk: selector for the stack/heap section
		  Also has selectors for kernel bootstrap, which uses an RBTree 
	      for something.
|-- uvm_amap.c
|-- uvm_amap.h
    * Contains forward declaration of uvm amap and prototype of functions, but
      no implementation of uvm amap. Amaps group sets of anons that are mapped
      together.
|-- uvm_anon.c
|-- uvm_anon.h
    * Contains prototypes of uvm anon and aref funcs and ds. The data can be in the
      following states. (1) in a vm_page with no backing store allocated yet, (2)
      in a vm_page with backing store, or (3) paged out to backing store with no
      vm_page in RAM
        - Vm_anon is a structure used to describe a page of anonymous(short term)
          memory that will go away when processes are done referencing it
            1. an_lock - rwlock protectnig this anon
            2. an_page - vm_page backing this anon if it is in ram 
            3. an_ref - # of processes referencing this anon 
            4. an_swslot - Drum swap slot # ??? 
        - Vm_aref is used to reference an anonymous virtual memory map(amap.h)  
            1. ar_pageoff - page offset into the anonymous map
            2. ar_amap - the backing amap 
|-- uvm_aobj.c
|-- uvm_aobj.h
    * Contains prototypes for a uvm anonymous object funcs, which is a backing object
      for anonymous memory(contains no ds)
|-- uvm_ddb.h
    * Contains print functions prototypes for DDB though unsure where those are defined
|-- uvm_device.c
|-- uvm_device.h
    * Contains prototypes of funcs and ds for uvm_device 
        - uvm_device is a device handle into the VM system.
            1. u_obj - backign uvm object
            2. u_flags - flags(I think below) 
                i. UVM_DEVICE_HOLD      - a process or thread has a hold on the device
               ii. UVM_DEVICE_WANTED    - a process or thread wants a hold on the device
            3. u_device - a struct representing the device
            4. u_list - global list of device objects
|-- uvm_extern.h
|-- uvm_fault.c
|-- uvm_fault.h
    * Contains the arguments to the fault handler and fault func prototypes, though
      unsure how these are connected to eachother
        - 3 types of faults
            1. VM_FAULT_INVALID - invalid mapping
            2. VM_FAULT_PROTECT - access does not match protection
            3. VM_FAULT_WIRE    - wire mapping?  
        - uvm_faultinfo is the argument struct to the fault handler
            1. orig_map - the original faulting map
            2. orig_rvaddr - original rounded addr where fault occurred 
            3. orig_size - original size of fault
            4. map - map, could be a submap 
            5. mapv - map's version # 
            6. entry - faulting entry of map 
            7. size - size of interest
|-- uvm_glue.c
|-- uvm_glue.h
|-- uvm_init.c
|-- uvm_io.c
|-- uvm_km.c
|-- uvm_km.h
|-- uvm_map.c
|-- uvm_map.h
    * Contains prototypes of vm_map and vm_map_entry ds and funcs
        - Vm_map_entries are structures containing entries in a vm_map.
            1. Entries are stored in a red-black tree for userland processes
               and a singly linked list for the kernel
            2. NOTE: What is dfree?
            3. Entries contain the start and end virtual addresses they cover,
               the amount of guard and free space, a backing uvm_object or sub_map
               and the offset into this backing store, an aref for anonymous memory
               handling, flags indicating proection, inheritance, whether the memory 
               is wired or not, advice, and other flag types. We also have the entry type,
               which uses the 'ETYPE' macros in uvm.h.
            4. NOTE: What is fspace_augment?
        - Vm_maps are rbtrees of free space and map entries
            1. uvm_map_addr - red black tree of entries sorted by address.
            2. NOTE: what is sserial and wserial?
            3. pmap - The physical map interface used by this vm_map
            4. size - size of space covered by map 
            5. ref_count - # of processes that need this map 
            6. flags 
                  i. VM_MAP_PAGEABLE      - entries are pageable
                 ii. VM_MAP_INTRSAFE      - entries are interrupt safe
                iii. VM_MAP_WIREFUTURE    - wire future entries 
                 iv. VM_MAP_BUSY          - map is busy 
                  v. VM_MAP_WANTLOCK      - want to write-lock 
                 vi. VM_MAP_GUARDPAGES    - add guard pages to map  
                vii. VM_MAP_ISVMSPACE     - map is a vmspace
               viii. VM_MAP_SYSCALL_ONCE  - libc syscall registered ? 
            7. timestamp - version number added after each change to signal when
               certain ops must restart 
            8. min/max offset - first and last addr over map entries
            9. b_start/b_end - beginning and end address for brk/heap allocation
           10. s_start/s_end - beginning and end address for stack allocation
           11. busy - point to the process holding busy on this map(can be NULL)
           12. uaddr_exe - address selector for the executable pages of memory. Used if protX
               is selected, or 'the pointer is not NULL'?
           13. uaddr_any - if the criteria for uaddr_exe is not fulfilled, these selectors
               are tried in the order they appear
           14. uaddr_brk_stack - selector for brk/stack area
           15. lock/mtx - rwlock which is non-interrupt safe and mtx which is interrupt safe.
           16. flags_lock - mutex for flags.
|-- uvm_meter.c
|-- uvm_mmap.c
|-- uvm_object.c
|-- uvm_object.h
|-- uvm_page.c
|-- uvm_page.h
    * Contains prototypes of vm_page ds and funcs
        - Vm_pages are data structures kept
          for pages resident in memory. 
            1. Each page is an entry in globals: a page tail queue and 
               a red black tree referred to as the object tree.
            2. uanon - Anon page for anonymous memory(WHY?)
            3. uobject - backing object 
            4. offset - offset into object where page is 
            5. pg_flags - flags
                    i. PG_BUSY          - page is locked
                   ii. PG_WANTED        - page is being waited on 
                  iii. PG_TABLED        - page is in VP table ? 
                   iv. PG_CLEAN         - page has not been modified since being paged in 
                    v. PG_CLEANCHK      - page clean bit has been checked 
                   vi. PG_RELEASED      - page released while paging 
                  vii. PG_FAKE          - page is not yet initialized 
                 viii. PG_RDONLY        - page must be mapped read-only 
                   ix. PG_ZERO          - page has been zero'd out  
                    x. PG_DEV           - page is in device space  
                   xi. PG_PAGER1        - pager specific flag 
                  xii. PQ_FREE          - page is in free list 
                 xiii. PQ_INACTIVE      - page is in inactive list 
                  xiv. PQ_ACTIVE        - page is in active list 
                   xv. PQ_ANON          - page is part of an anon rather than object 
                  xvi. PQ_AOBJ          - page is part of an anonymous object 
                 xvii. PQ_SWAPBACKED    - page is part of anon or anonymous object, i.e. it is
                                          backed by swap space. 
                xviii. PQ_ENCRYPT       - page needs encryption and decryption 
                xviii. PG_PMAPN         - flags reserved for pmaps with N in {0, ..., 5} 
            6. pg_version - version number incrememnted whenever page is modified
            7. wire_count - number of processes/threads that need this page wired into memory
            8. phys_addr - physical address of page
            9. fpgsz - free page range size 
           10. mdpage - machine dependent physical map page data
           11. owner/owner_tag - debugging fields for tracking which thread is using which page
        - Vm_physseg structures describe a physical memory segment
            1. start/end - PF# of first and (last + 1) page in segment (PF#?)
            2. avail_start/avail_end - PF# of first and (last + 1) free page in segment (PF#?)
            3. pgs - vm_page structures matching each page from the start
            4. lastpg - vm_page structure matching the last page
        - Vm_page_zero_enable ?(defined externally)
        - Vm_physmem ?(defined externally)
|-- uvm_pager.c
|-- uvm_pager.h
|-- uvm_param.h
|-- uvm_pdaemon.c
|-- uvm_pmap.h
|-- uvm_pmemrange.c
|-- uvm_pmemrange.h
|-- uvm_swap.c
|-- uvm_swap.h
|-- uvm_swap_encrypt.c
|-- uvm_swap_encrypt.h
|-- uvm_unix.c
|-- uvm_vnode.c
|-- uvm_vnode.h
`-- uvmexp.h

0 directory, 44 files
