/usr/src/sys/uvm
|-- uvm.h 
	* Contains global uvm state data
		- Queue and locks(mutex) for active/inactive and free pages
		- State for pagedaemon and async io tasks
		- Bool indicating when init has completed
		- Entity type bits for indicating properties of map entries
		- Some uvm_addr decls(unsure if these should be here)
|-- uvm_addr.c
|-- uvm_addr.h
	* Contains prototypes of uvm addr selector funcs and ds
		- Addr selectors are different algorithms that decide where
		  to put addresses. They are defined by a struct containing 
		  an interface(struct of function pointers) and some state
		  data(max and min addrs). The interface has a few methods
		  for selecting, freeing, and printing addresses. There are
		  5 different selectors atm:
			1. uaddr_lin: unsure, disabled by default
			2. uaddr_rnd: random algo addrs
			3. uaddr_bestfit: bestfit algo addrs
			4. uaddr_pivot: pivot algo addrs(patch this)
			5. uaddr_stack_brk: selector for the stack/heap section
		  Also has selectors for kernel bootstrap, which uses an RBTree 
	      for something.
|-- uvm_amap.c
|-- uvm_amap.h
    * Contains forward declaration of uvm amap and prototype of functions, but
      no implementation of uvm amap. Amaps group sets of anons that are mapped
      together.
|-- uvm_anon.c
|-- uvm_anon.h
    * Contains prototypes of uvm anon and aref funcs and ds. The data can be in the
      following states. (1) in a vm_page with no backing store allocated yet, (2)
      in a vm_page with backing store, or (3) paged out to backing store with no
      vm_page in RAM
        - Vm_anon is a structure used to describe a page of anonymous(short term)
          memory that will go away when processes are done referencing it
            1. an_lock - rwlock protectnig this anon
            2. an_page - vm_page backing this anon if it is in ram 
            3. an_ref - # of processes referencing this anon 
            4. an_swslot - Drum swap slot # ??? 
        - Vm_aref is used to reference an anonymous virtual memory map(amap.h)  
            1. ar_pageoff - page offset into the anonymous map
            2. ar_amap - the backing amap 
|-- uvm_aobj.c
|-- uvm_aobj.h
    * Contains prototypes for a uvm anonymous object funcs, which is a backing object
      for anonymous memory(contains no ds)
|-- uvm_ddb.h
    * Contains print functions prototypes for DDB though unsure where those are defined
|-- uvm_device.c
|-- uvm_device.h
    * Contains prototypes of funcs and ds for uvm_device 
        - uvm_device is a device handle into the VM system.
            1. u_obj - backign uvm object
            2. u_flags - flags(I think below) 
                i. UVM_DEVICE_HOLD      - a process or thread has a hold on the device
               ii. UVM_DEVICE_WANTED    - a process or thread wants a hold on the device
            3. u_device - a struct representing the device
            4. u_list - global list of device objects
|-- uvm_extern.h
    * Unsure, but I believe this file provides an externel interface to the kernel
      of the uvm library.
        - PROT_MASK         - (PROT_READ | PROT_WRITE | PROT_EXEC) mask for protection 
        - MAP_INHERIT_MASK  - mask that can be used to find inheritance
        - MADV_MASK         - mask for advice
        - Flags for uvm_maps 
            1. UVM_FLAG_FIXED      - find space
            2. UVM_FLAG_OVERLAY    - establish overlay 
            3. UVM_FLAG_NOMERGE    - don't merge map entries 
            4. UVM_FLAG_COPYONW    - set copy_on_write flag 
            5. UVM_FLAG_TRYLOCK    - fail if we cannot lock map 
            6. UVM_FLAG_HOLE       - no backend 
            7. UVM_FLAG_QUERY      - do everything except actual execution 
            8. UVM_FLAG_NOFAULT    - don't fault 
            9. UVM_FLAG_UNMAP      - unmap to make space 
           10. UVM_FLAG_STACK      - page may contain a stack 
           11. UVM_FLAG_WC         - write combining 
           12. UVM_FLAG_CONCEAL    - omit from dumps 
           13. UVM_FLAG_SYSCALL    - system calls allowed 
           14. UVM_FLAG_SIGALSTACK - sigalstack validation required 
        - Macros to extract/put flag info in map(from and to flags entry)
            1. UVM_PROTECTION    (flags)    - extract protection info using PROT_MASK
            2. UVM_INHERIT       (flags)    - extract inherit info using MAP_INHERIT_MASK
            3. UVM_MAXPROTECTION (flags)    - extract maximum protection using PROT_MASK
            4. UVM_ADVICE        (flags)    - extract advice using MADV_MASK 
            5. UVM_MAPFLAG                  - take prot, maxprot, inheritance, advice, and other flags
                                              and create a flag bit array for use in map 
        - UVM_UKNOWN_OFFSET - offset not known to object
        - uvm_km_kmemalloc flags 
            1. UVM_KMF_NOWAIT   - matches M_NOWAIT
            2. UVM_KMF_VALLOC   - allocate VA only(VA?) 
            3. UVM_KMF_CANFAIL  - caller handles failure 
            4. UVM_KMF_ZERO     - zero pages 
            5. UVM_KMF_TRYLOCK  - try locking only 
        - uvm_pagealloc flags 
            1. UVM_PGA_USERESERVE - ok to use reserve pages
            2. UVM_PGA_ZERO       - returned page must be zeroed 
        - uvm_pglistalloc/uvm_pmr_getpages flags 
            1. UVM_PLA_WAITOK       - may sleep
            2. UVM_PLA_NOWAIT       - will not sleep(need this or above, not both)
            3. UVM_PLA_ZERO         - zero all pages before returning
            4. UVM_PLA_TRYCONTIG    - try to allocate contig physmem
            5. UVM_PLA_FAILOK       - caller will handle failures 
            6. UVM_PLA_NOWAKE       - do not wake pagedaemon on failure 
            7. UVM_PLA_USERESERVE   - can allocate from kernel reserve memory 
        - lockfalgs that control locking behaviour for some functions
            1. UVM_LK_ENTER - map locked on entry
            2. UVM_LK_EXIT  - leave map locked on exit 
        - flags to uvm_page_physload
            1. PHYSLOAD_DEVICE - don't add to the page queue 
        - vmspace is a struct representing a shareable process virtual
          address space. May eventually be merged with vm_map.
          several fields are temporary. 
            1. vm_map           - this space's vm_map
            2. vm_refcnt        - reference count, protected by kernel lock 
            3. vm_shm           - SYS5 shared memory of private data 
            4. vm_rssize        - current resident size in pages 
            5. vm_swrss         - resident set size before last swap 
            6. vm_tsize         - text size in pages 
            7. vm_dsize         - data size in pages 
            8. vm_dused         - data segment length in pages 
            9. vm_ssize         - stack size in pages, protected by vm_map lock
           10. vm_taddr         - user virtual address of text, immutable
           11. vm_daddr         - user virtual address of data, immutable
           12. vm_maxsaddr      - user VA at max stack growth 
           13. vm_minsaddr      - user VA at top of stack 
           14. vm_execve        - execve systemcall stub region, protected by vm_map lock
           15. vm_execve_end    - execve systemcall stub region end, protected by vm_map lock
        - uvm_constraint_range are structures that allow MD code to setup constraint ranges for 
          memory allocators, the primary use for this is to keep allocation for certain memory
          consumers such as mbuf pools within address ranges that are reachable by devices that
          perform DMA. It is alos to discourage memory allocations from being satisfied from ranges
          such as the ISA memory range, if they can be satisfied with allocation from other ranges.
            1. ucr_low  - low constraint
            2. ucr_high - high constraint
        - md-code defined external constraint ranges
            1. isa_constraint       - constraint range for ISA memory
            2. dma_constraint       - constraint range for DMA memory
            3. no_constraint        - no constraint? 
            4. uvm_md_constraints   - array of constraints, not sure? 
        - kernel maps owned by md code, defined externally (unsure about these)
            1. exec_map 
            2. kernel_map
            3. kmem_map
            4. phys_map
        - kmem_va_mode is a struct defining the allocation mode for a virtual space
            1. kv_map        - pinter to the ponter the the map we're allocating from
            2. kv_align      - alignment
            3. kv_wait       - wait for free space in the map if it's full. The default
                               allocators don't wait since running out of space in kernel_map and 
                               kmem_map is usually fatal. Special maps like exec_map are specifically
                               limited, so waiting for space in them is necessary
            4. kv_singlepage - use the single page allocator
            5. kv_executable - map the physical pages with PROT_EXEC 
        - kmem_pa_mode is a struct defining the allocation mode for a physical pages 
            1. kp_constraint - allocation constraint for physical pages
            2. kp_object     - if the pages should be allocated from an object
            3. kp_align      - physical alignment of the first page in the allocation 
            4. kp_boundary   - boundary that the physical addresses can't cross if the allocation is 
                               contiguous 
            5. kp_nomem      - don't allocate any backing pages
            6. kp_maxseg     - maximal amount of contiguous segments
            7. kp_zero       - zero the returned memory
            8. kp_pageable   - allocated pageable memory
        - kmem_dyn_mode is a struct holding dynamic allocation paramters. Stuff that changes too often or too
          much to create separate va and pa modes for. 
            1. kd_prefer   - offset to fee to PMAP_PREFER
            2. kd_waitok   - is it ok to sleep?
            3. kd_trylock  - don't sleep on map locks 
            4. kd_slowdown - special parameter for the singlepage va allocator that tells
                             the caller to sleep if possible to let the singlpage allocator
                             allocator catch up. 
        - extern defs for kmem_va_mode
            1. kv_any
            2. kv_intrsafe
            3. kv_page
        - extern defs for kmem_pa_mode
            1. kp_dirty
            2. kp_zero
            3. kp_dma
            4. kp_dma_contig
            5. kp_dma_zero
            6. kp_pageable
            7. kp_none
        - extern defs for kmem_dyn_mode
            1. kd_waitok
            2. kd_nowait
            3. kd_trylock
|-- uvm_fault.c
|-- uvm_fault.h
    * Contains the arguments to the fault handler and fault func prototypes, though
      unsure how these are connected to eachother
        - 3 types of faults
            1. VM_FAULT_INVALID - invalid mapping
            2. VM_FAULT_PROTECT - access does not match protection
            3. VM_FAULT_WIRE    - wire mapping?  
        - uvm_faultinfo is the argument struct to the fault handler
            1. orig_map - the original faulting map
            2. orig_rvaddr - original rounded addr where fault occurred 
            3. orig_size - original size of fault
            4. map - map, could be a submap 
            5. mapv - map's version # 
            6. entry - faulting entry of map 
            7. size - size of interest
|-- uvm_glue.c
|-- uvm_glue.h
    * Defines two function prototypes and no ds. More explanation in uvm_glue.c
|-- uvm_init.c
|-- uvm_io.c
|-- uvm_km.c
|-- uvm_km.h
    * Contains prototypes of funcs and ds for kernel virtual memory
      management. 
        - Uvm_km_free_page are structures that define a linked list
          of some kind, though they don't appear to have any other
          fields.
        - Uvm_km_pages is a global structure for managing uvm kernel pages
            1. mtx - a mutex protecting the global struct
            2. lowat/hiwat - low and high address watermarks(I think this means min and max?)
            3. free / page - I believe page is an array of addresses of kernel pages and 
               free is how many pages are free.
            4. freelist / freelistlen - linked list of uvm_km_free_page structs though I don't know
               how these work.
            5. km_proc - process that manages kernel memory?
|-- uvm_map.c
|-- uvm_map.h
    * Contains prototypes of vm_map and vm_map_entry ds and funcs
        - Vm_map_entries are structures containing entries in a vm_map.
            1. Entries are stored in a red-black tree for userland processes
               and a singly linked list for the kernel
            2. NOTE: What is dfree?
            3. Entries contain the start and end virtual addresses they cover,
               the amount of guard and free space, a backing uvm_object or sub_map
               and the offset into this backing store, an aref for anonymous memory
               handling, flags indicating proection, inheritance, whether the memory 
               is wired or not, advice, and other flag types. We also have the entry type,
               which uses the 'ETYPE' macros in uvm.h.
            4. NOTE: What is fspace_augment?
        - Vm_maps are rbtrees of free space and map entries
            1. uvm_map_addr - red black tree of entries sorted by address.
            2. NOTE: what is sserial and wserial?
            3. pmap - The physical map interface used by this vm_map
            4. size - size of space covered by map 
            5. ref_count - # of processes that need this map 
            6. flags 
                  i. VM_MAP_PAGEABLE      - entries are pageable
                 ii. VM_MAP_INTRSAFE      - entries are interrupt safe
                iii. VM_MAP_WIREFUTURE    - wire future entries 
                 iv. VM_MAP_BUSY          - map is busy 
                  v. VM_MAP_WANTLOCK      - want to write-lock 
                 vi. VM_MAP_GUARDPAGES    - add guard pages to map  
                vii. VM_MAP_ISVMSPACE     - map is a vmspace
               viii. VM_MAP_SYSCALL_ONCE  - libc syscall registered ? 
            7. timestamp - version number added after each change to signal when
               certain ops must restart 
            8. min/max offset - first and last addr over map entries
            9. b_start/b_end - beginning and end address for brk/heap allocation
           10. s_start/s_end - beginning and end address for stack allocation
           11. busy - point to the process holding busy on this map(can be NULL)
           12. uaddr_exe - address selector for the executable pages of memory. Used if protX
               is selected, or 'the pointer is not NULL'?
           13. uaddr_any - if the criteria for uaddr_exe is not fulfilled, these selectors
               are tried in the order they appear
           14. uaddr_brk_stack - selector for brk/stack area
           15. lock/mtx - rwlock which is non-interrupt safe and mtx which is interrupt safe.
           16. flags_lock - mutex for flags.
|-- uvm_meter.c
|-- uvm_mmap.c
|-- uvm_object.c
|-- uvm_object.h
    * Defines the prototypes and ds of the uvm_object module. 
        - uvm_objects represent a list of pages, which are managed by
          the object's pager. All pages that belong to an
          object are protected using it's lock.
            1. vmobjlock -  The lock may be shared amongst uvm objects. Lock
                            sharing is usually used when there is an undelrying object. 
                            For example. vnode representing a file may have an underlying
                            node, which is the case for tmpfs and layered file systems. In such a case, 
                            vnode's UVM object and the underlying UVM object shares the lock.
            2. pg_ops    - uvm_pager or this object's pages                  
            3. memt      - red-black tree of vm_pages of this object 
            4. uo_npages - # of pages in memt 
            5. uo_refs   - reference count for this object. The reference count is managed atomically for 
                           the anonymous UVM objects. For other objects. it is arbitrary 
                           (may use the lock or atomics).
        - UVM_OBJ_KERN is a 'special' uo_refs values which indicates that the object is a kernel memory
          object rather than a normal one (kernel memory objects don't have reference counts -- they
          never die). this value is used to detect kernel object mappings at uvm_unmap() time. normally
          when an object is unmapped its pages eventually become deactivated and then paged out and/or
          freed. this is not useful for kernel objects... when a kernel object is unmapped we always 
          want to free the resources associated with the mapping. UVM_OBJ_KERN allows us to decide which
          type of unmapping we want to do. in addition, we have kernel objects which may be used in an 
          interrupt context. these objects get their mappings entered with pmap_kenter and removed with
          pmap_kremove, which are safe to call in interrupt context, and must be used ONLY for wired kernel
          mappings in these objects and their associated maps.
        - UVM_OBJ_IS_KERN_OBJECT - macro that checks if an obj is a kern obj
        - extern const uvm_vnodeops/uvm_deviceops/pmap_pager/bufcache_pager are all the pagers
          defined throughout uvm
        - uvm_pagecmp - comparison function for objtree.
        - UVM_OBJ_IS_VNODE      - macro that detects if this object is a vnode
        - UVM_OBJ_IS_DEVICE     - macro that detects if this object is a device 
        - UVM_OBJ_IS_VTEXT      - macro that detects if this object is a vtext
        - UVM_OBJ_IS_AOBJ       - macro that detects if this object is a aobj
        - UVM_OBJ_IS_PMAP       - macro that detects if this object is a pmap
        - UVM_OBJ_IS_BUFCACHE   - macro that detects if this object is a bufcache 
        - UVM_OBJ_IS_DUMMY      - macro that detects if this object is a dummy
|-- uvm_page.c
|-- uvm_page.h
    * Contains prototypes of vm_page ds and funcs
        - Vm_pages are data structures kept
          for pages resident in memory. 
            1. Each page is an entry in globals: a page tail queue and 
               a red black tree referred to as the object tree.
            2. uanon - Anon page for anonymous memory(WHY?)
            3. uobject - backing object 
            4. offset - offset into object where page is 
            5. pg_flags - flags
                    i. PG_BUSY          - page is locked
                   ii. PG_WANTED        - page is being waited on 
                  iii. PG_TABLED        - page is in VP table(believe VP stands for Virtual Page) ? 
                   iv. PG_CLEAN         - page has not been modified since being paged in 
                    v. PG_CLEANCHK      - page clean bit has been checked 
                   vi. PG_RELEASED      - page released while paging 
                  vii. PG_FAKE          - page is not yet initialized 
                 viii. PG_RDONLY        - page must be mapped read-only 
                   ix. PG_ZERO          - page has been zero'd out  
                    x. PG_DEV           - page is in device space  
                   xi. PG_PAGER1        - pager specific flag 
                  xii. PQ_FREE          - page is in free list 
                 xiii. PQ_INACTIVE      - page is in inactive list 
                  xiv. PQ_ACTIVE        - page is in active list 
                   xv. PQ_ANON          - page is part of an anon rather than object 
                  xvi. PQ_AOBJ          - page is part of an anonymous object 
                 xvii. PQ_SWAPBACKED    - page is part of anon or anonymous object, i.e. it is
                                          backed by swap space. 
                xviii. PQ_ENCRYPT       - page needs encryption and decryption 
                xviii. PG_PMAPN         - flags reserved for pmaps with N in {0, ..., 5} 
            6. pg_version - version number incrememnted whenever page is modified
            7. wire_count - number of processes/threads that need this page wired into memory
            8. phys_addr - physical address of page
            9. fpgsz - free page range size 
           10. mdpage - machine dependent physical map page data
           11. owner/owner_tag - debugging fields for tracking which thread is using which page
        - Vm_physseg structures describe a physical memory segment
            1. start/end - PF# of first and (last + 1) page in segment (PF? I think this stands for Page Frame)
            2. avail_start/avail_end - PF# of first and (last + 1) free page in segment 
            3. pgs - vm_page structures matching each page from the start
            4. lastpg - vm_page structure matching the last page
        - Vm_page_zero_enable ?(defined externally)
        - Vm_physmem ?(defined externally)
|-- uvm_pager.c
|-- uvm_pager.h
    * Contains definition of uvm_pager interface
        - uvm_pagerops is a struct defining the operations a page
          must implement
            1. pgo_init         - void(void) func that inits the pager
            2. pgo_reference    - void(uvm_object) func that adds a ref to a uvm object 
            3. pgo_detach       - void(uvm_object) func that drops a ref to a uvm object 
            4. pgo_fault        - int(uvm_faultinfo *, ...) func that, if present, is used to
                                  perform specialized fault handling. Returns a status code 
                                  described below
            5. pgo_flush        - boolean_t(uvm_object, ...) func that flushes a page out of an object 
            6. pgo_get          - int(uvm_object, ...) func that gets/read page out of an object 
            7. pgo_put          - int(uvm_object, ...) func that put/writes page into an object 
            8. pgo_cluster      - void(uvm_object, ...) func that returns range of a cluster ?
            9. pgo_mk_pcluster  - vm_page**(uvm_object, ...) func that returns a "put" cluster?
        - flags for pager(mostly flush op)
            1. PGO_CLEANIT     - write dirty pages ot backing store
            2. PGO_SYNCIO      - if PGO_CLEANIT use sync I/O
            3. PGO_DEACTIVATE  - deactivate flushed pages 
            4. PGO_FREE        - free flushed pages 
            5. PGO_ALLPAGES    - flush whole object/get all pages
            6. PGO_DOACTCLUST  - flag to make mk_pcluster to include active pages 
            7. PGO_LOCKED      - fault data structures are locked [used for get]
            8. PGO_PDFREECLUST - daemon's free cluster flag [used for put]
            9. PGO_REALLOCSWAP - reallocate swap area [used for dropcluster?] 
           10. PGO_NOWAIT      - do not wait for inode lock
           11. PGO_DONTCARE    - for pages we are not interested in getting, used in get only 
        - flags to uvm_pagermapin
            1. UVMPAGER_MAPIN_WAITOK - allow waiting
            2. UVMPAGER_MAPIN_READ   - host <- device ? 
            3. UVMPAGER_MAPIN_WRITE  - device -> host (pseudo flag) ? 
        - get/put return values
            1. VM_PAGER_OK      - operation was successful 
            2. VM_PAGER_BAD     - specified data was out of the accepted range 
            3. VM_PAGER_FAIL    - specified data was in range, but doesn't exist 
            4. VM_PAGER_PEND    - operations was initiated but not completed 
            5. VM_PAGER_ERROR   - error while accessing data that is in range and exists 
            6. VM_PAGER_AGAIN   - temporary resource shortage prevented operation from happening 
            7. VM_PAGER_UNLOCK  - unlock the map and try again 
            8. VM_PAGER_REFAULT - [uvm_fault internal use only!] unable to relock data structures,
                                  thus the mapping needs to be reverified before we can proceed 
        - PAGER_MAP_SIZE - needed until the device strategy interface has changed to do physically addressed
                           I/O?
|-- uvm_param.h
    * Contains machine independent virtual memory parameters. 
        - boolean_t is defined here as an int
        - default page size is 4096
        - atop/ptoa - converts physical addresses to the page their in and
                      vice versa?
        - round_page / trunc_page - perform those operations on pages
|-- uvm_pdaemon.c
|-- uvm_pmap.h
    * Contains prototypes and ds to describe machine address mapping definitions 
      -- machine independent section
        - pmap_statistics is a struct allowing each machine dependent implementation
          to maintain expected statistics. They may do this anyway they choose, but are
          expected to return the statistics in this struct.
            1. resident_count - # of pages mapped total
            2. wired_count    - # of pages wired
        - flags passed to pmap_enter. Note the bottom 3 bits are PROT_* bits, used to
          indicate the access typw that was made (to seed modified and referenced 
          information).
            1. PMAP_WIRED   - wired mapping
            2. PMAP_CANFAIL - can fail if resource shortage
            3. PMAP_MDN     - machine dependent flags with N in {0, ..., 3} 
            4. PMAP_WC      - unknown?
        - Other interface functions, will most likely add here if needed
|-- uvm_pmemrange.c
|-- uvm_pmemrange.h
    * Contains prototypes and ds to describe and manage free physical memory 
        - global rbtrees of vm_pages, called uvm_pmr_add and uvm_pmr_size
        - page types
            1. UVM_PMR_MEMTYPE_DIRTY - this page may contain random data
            2. UVM_PMR_MEMTYPE_ZERO  - this page has been zeroed     
            3. UVM_PMR_MEMTYPE_MAX   - array size used below
        - uvm_pmemrange describes an address range of memory
            1. addr     - red-black tree of free page chunks, sorted by addr, uses uvm_pmr_addr_cmp
            2. size     - array of red-black trees of free page chunks, sorted by size, uses uvm_pmr_size_cmp. 
                          Uses UVM_PMR_MEMTYPE_MAX for size
            3. single   - array of tail queues of single page regions using pageq. 
                          Uses UVM_PMR_MEMTYPE_MAX for size
            4. low      - start of address range
            5. high     - end of address range + 1
            6. use      - use counter
            7. nsegs    - current range count
            8. uvm_pmemrange is an entry in a tail queue pmr_use sorted by use counter
            9. uvm_pmemrange is an entry in a red-black tree pmr_addr sorted by address
        - uvm_pmalloc is a struct containing a description of failing memory allocation.
          there are two ways new pages become available. (1) the page daemon drops them
          and (2) a process calls free. The buffer cache and page daemon can decide that
          they don't have the ability to make pages available in the requested range. In that case,
          the FAIL bit will be set. There's a possibility that a page is no longer on the queues
          but has not yet been freed, or that a page was busy. Also, wired pages are not considered
          for paging, so they could cause a failure that may be recoverable.
            1. entry in a tail queue named pmq
            2. pm_constaint/pm_size - allocation request paramters in the form of uvm_constraint range(defined in uvm_extern)
               and pm_size of constraint range
            3. pm_flags - state flags
                i. UVM_PMA_LINKED - uvm_pmalloc is on list
               ii. UVM_PMA_BUSY   - entry is busy with fpageq unlocked 
              iii. UVM_PMA_FAIL   - page daemon cannot free pages 
               iv. UVM_PMA_FREED  - at least one page in the range was freed 
        - Red-black tree named uvm_pmemrange_addr of uvm_pmemranges, uses uvm_pmemrange_addr_cmp.
        - Tail queue named uvm_pmemrange_use of uvm_pmemranges
        - uvm_pmr_control is a struct for controlling uvm_pmemranges
            1. addr - red-black tree of uvm_pmemranges sorted by addr
            2. use  - tail queue of uvm_pmemranges sorted by use? 
            3. allocs - tail queue of uvm_pmallocs.
|-- uvm_swap.c
|-- uvm_swap.h
|-- uvm_swap_encrypt.c
|-- uvm_swap_encrypt.h
|-- uvm_unix.c
|-- uvm_vnode.c
|-- uvm_vnode.h
`-- uvmexp.h

0 directory, 44 files
